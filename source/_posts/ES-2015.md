---
title: ES2015
date: 2017-02-27 22:59:32
tags: Programming
---

### A better length method for unicode text
``` javascript
function codePointLen(text) {
  let result = text.match(/[\s\S]/gu);
  return result ? result.length : 0;
}
```

### Default param
A trivial version
``` javascript
function getID(name, defaultValue) {
  defaultValue = defaultValue || 1000;
  // ...
}
```

The problem is defaultValue would be ignored with falsy value like 0. As a result, a more decent version before ES2015 is
``` javascript
function getID(name, defaultValue) {
  defaultValue = (typeof defaultValue !== "undefined") ? defaultValue : 0;
  // ...
}
```

In ES2015, it can be simplified as
``` javascript
function getID(name, defaultValue=1000) {
  // ...
}
```

### Apply, call and array destructuring
``` javascript
let values = [4,3,1,2];

// Because Math.max doesn't accept array. Please remember that "call" accepts multiple params and do the same function invocation as "apply" 
console.log(Math.max.apply(Math, values));

// The first param can be anything since max is a pure function (instead of a method)
console.log(Math.max.apply(null, values));

// But it's easier with array destructuring
console.log(Math.max(...values));
```
### How to check whether a function is called with "new"
``` javascript
function Person(name) {
  if (this instanceof Person) {
    this.name = name;
  } else {
    throw new Error("Call Person with new, please");
  }
}

let p1 = new Person("tom");

// It can be checked by Person and throw the error
// let p2 = Person("jerry");

// No error with this call 
let p2 = Person.call(p1, "jerry");

console.log(p1.name); //jerry
console.log(p2); //undefined
```

ES2015 fixes the issue with:
``` javascript
function Person(name) {
  // "new.target" is not supported in safari (on iPhone, iPad and Mac)
  if (typeof new.target !== "undefined") {
    this.name = name;
  } else {
    throw new Error("Call Person with new, please");
  }
}
```

### Differences between arrow function and normal one
- No this, super and new.target bindings; No prototype and arguments
- Can't be called with new (since arrow function doesn't have [[Construct]], only [[Call]])
- Can't change this, which remains the same throughout the life cycle of the function

### Tail call optimization
In theory, the optimization is enabled when the tail call has no dependency to the current stack and there is no further work to do after the call, plus the call must return as the function value. So this won't be optimized:
``` javascript
function fact(n) {
  if (n <= 1) {
    return 1;
  } else {
    return n * fact(n-1);
  }
}
```

In fact, I notice it is quite efficient (in safari on Mac). fact(170), the maximum param making the result less than infinity, is as fast as below, which is regarded as optimized:
``` javascript
function fact(n, p=1) {
  if (n <= 1) {
    return 1*p;
  } else {
    return fact(n-1, n*p);
  }
}
```

Here is another example:
``` javascript
function fibo(n, i=2, p1=1, p2=1) {
  if (n < 0) {
    throw new Error("param n can't be less than zero");
  } else if (n < 2) {
    return 1;
  } else {
    if (n === i) {
      return p1 + p2;
    } else {
      return fibo(n, i+1, p1+p2, p1);
    }
  }
}
```
